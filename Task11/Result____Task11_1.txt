//Фабричний метод чи абстрактна фабрика? я за фабрику. В описі швидше подібно на фабрику. 
Я вважаю, що продукти потрiбно реалiзуваты згiдно за паттерном <<Фабричний метод>>
— це породжувальний патерн проектування, який визначає загальний інтерфейс для створення об’єктів у суперкласі, 
дозволяючи підкласам змінювати тип створюваних об’єктів.

Тобто буде класс AbstractDeveloper за допомогою якого будуть створюватись новi види продукту на основi спiльного iнтрефейсу
IProduct, а його вже будуть реалiзувати необхiднi нам продукти:

- класи продуктiв будуть лише Data классами вони будуь зберiгати стан когжного окремого продукту 

також треба зауважити, що для створення кожного новогу продукту потрiбен клас який буде наслiдуватись вiд AbstractDeveloper
та буде створювати потрiбнi нам класи продуктiв. Таким чином за допомогою данного паттерну могжна буде реалiзовувати довiльну
кiлькiсть унiкальних продуктiв в одному мiсцi..

Тим самим клас Storage буде також зберiгати всi продукти за допомогою iнтерфейсу IProduct.
Все, що потрiбно мати це те щоб бути обгорткою над IList<IProduct>
(додавати, видаляти, отримувати, тощо необхiднi продукти)

Також нам буде потрiбен клас ProductService
 - який буде корегувати цiну для всiх продуктiв
 - окремих продуктiв
 - збiльшувати/зменшувати кiлькiсть продуктiв на складi

 В планi узагальнення я вважаю що краще буде мати список саме iнтерфейсiв IProduct

 саме в задачi 12_1 - 12_2 я вже це побудував=)
 проект явно вирiс, але насамперед ми маемо певнi розширення, якi дають нам безлiч можливостей
 додавання нових продуктiв не змiнюючи при цьому Storage...

на мою думку така структура проекту буде:
 - оптимальною для росширення бази продуктiв
 - зможе покрити безлiч нових утворенних продуктiв
 - Позбавляє клас Storage від прив’язки до конкретних класів продуктів.
 - спростить підтримку коду.
 - продукти будуть створюватись в одному мicцi
 - Реалізує принцип відкритості/закритості.
 
і навіть, якщо ми захочемо перенести данні до бази данних..клас Storage нам буде потрібен щоб
підгружати данні/обробляти і загружати назад до бази.
Тому він буде відігрувати буферну роль i також не втратить свою принадлжнiсть.



abstract class AbstactDeveloper : MethodCreateProduct() => IProduct
	class DairyDeveloper		 : AbstractDeveloper	 => new Dairy()
	class ProductDeveloper		 : AbstractDeveloper     => new Product()
	class MeatDeveloper			 : AbstractDeveloper     => new Meat()

interface IProduct 
	class Product : IProduct			=> new Product()
	class Dairy	  : IProduct,Product	=> new Dairy()
	class Meat    : IProduct,Product	=> new Meat()


Interface IReadServise	// можна буде на основi цього iнтерефейсу створювати безлiч читачiв з рiзних джерел
	class Reader : IReadServise 

Interface IWriteServise	// можна буде на основi цього iнтерефейсу створювати безлiч писателiв у рiзнi джерела
	class Writer : IReadServise

Interface ISerializationTranslateServise // який буде на основi цього iнтерефейсу оброблювати зчитану iнформацiю 
	class Translator : IReadServise 


	class ProductsServise	// для управлiння Storage :
							- обробляти events
							- загружати выгружити у БД
							- регулювати цiни
							- списувати простроченi товари 
							- обробляти невiрно зчитанi даннi
							- записувати помилки у файл лог

	Enums Category, Type  // без змiн 
	Class Check			  // без змiн
//Не зрозуміла ідею ключа в наступному словнику
	Class Buy			  // додати клiента (id, name, email, phone) зробивши Dictionary(IPerson<List<Iproduct> buy);
	class BuyRepository   // буде отгорткою Dictionary<Guid, Buy> buys
	class BuyServise      // для управлiння BuyRepository :
							- обробляти events
							- загружати выгружити у БД
							- розсилати повiдомлення про знижки
							- обробляти невiрно зчитанi даннi
							- записувати помилки у файл лог

Interface Iperson
	class Person : Iperson
	class PersonRepository   // буде отгорткою Dictionary<Guid, Person> persons
	class PersonServise      // для управлiння BuyRepository :
							- обробляти events
							- загружати выгружити у БД
							- розсилати повiдомлення про знижки
							- поздоровлять з днем народження
							- обробляти невiрно зчитанi даннi
							- записувати помилки у файл лог

	class PLL // Який буде спiлкуватись з клiентами через класи { ProductsServise && PersonServise&& BuyServise }
							- питати звiдки загружати продукти
							- куди загружати продукти
							- по запитам видавати iнформаiю по продуктам
							- додавати до классу Buy
							- друкувати чек Check
							- аналiзувати популярнi продукти
							- читати LOG
							- оброьляти LOG
							- матиме меню з обробки Exceptions




